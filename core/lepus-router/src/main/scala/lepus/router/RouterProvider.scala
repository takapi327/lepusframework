/** This file is part of the Lepus Framework. For the full copyright and license information, please view the LICENSE
  * file that was distributed with this source code.
  */

package lepus.router

import cats.data.NonEmptyList

import lepus.router.model.{ Schema, ServerResponse }
import lepus.router.http.{ Request, Response }

/** A model for providing routing information to the server. Only one must be generated by the application.
  *
  * For example:
  * {{{
  *  object HttpApp extends RouterProvider[IO]:
  *    override def routes = combine(
  *      "hello" / name -> HelloRoute,
  *      "world" / country -> WorldRoute
  *    )
  * }}}
  *
  * @tparam F
  *   the effect type.
  */
trait RouterProvider[F[_]]:

  def routes: NonEmptyList[Routing[F]]

  /** Combine routing into a single array for use in the application.
    *
    * @param route
    *   Receive all combinations of Endpoints and Routers used in the application.
    */
  def combine(route: Routing[F]*): NonEmptyList[Routing[F]] =
    require(route.nonEmpty, "There must always be at least one Route.")
    NonEmptyList.fromListUnsafe(route.toList)

final class Router[F[_], I: Schema, O: Schema, T] private[lepus] (val action: Requestable[F, T]):

  val input:  Schema[I] = summon[Schema[I]]
  val output: Schema[O] = summon[Schema[O]]

object Router:

  def of[F[_], I: Schema, O: Schema, T](
    action: Requestable[F, T]
  ): Router[F, I, O, T] = Router[F, I, O, T](action)
